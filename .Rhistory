ord.args$Y
A
Y <- ord.args$Y
transform. <- ord.args$transform.
tol <- ord.args$tol
Cov <- NULL
scale. <- F
rank. <- NULL
newdata <- NULL
Y <- try(as.matrix(Y), silent = TRUE)
Y
class(Y)
I <- diag(n)
I
id <- if (!is.null(rownames(Y)))  rownames(Y) else 1:n
if (is.null(A))  A <- I
if (!is.matrix(A))   stop("A must be a matrix with the same number of rows as Y\n",
call. = FALSE)
A
A <- NULL
Y <- ord.args$Y
transform. <- ord.args$transform.
tol <- ord.args$tol
Cov <- NULL
scale. <- F
rank. <- NULL
newdata <- NULL
A <- NULL
Y <- try(as.matrix(Y), silent = TRUE)
if (inherits(Y, "try-error")) stop("Y must be a matrix or data frame.\n", call. = FALSE)
alignment <- if (!is.null(A)) try(deparse(substitute(A)), silent = TRUE) else "principal"
if (length(alignment) != 1) alignment <- "A"
dims <- dim(Y)
n <- dims[1]
p <- dims[2]
I <- diag(n)
id <- if (!is.null(rownames(Y)))  rownames(Y) else 1:n
if (is.null(A))  A <- I
if (!is.matrix(A))   stop("A must be a matrix with the same number of rows as Y\n",
call. = FALSE)
if (NROW(A) != n)
if (NROW(A) != n) stop("A must be a matrix with the same number of rows as data\n",
call. = FALSE)
if (is.null(rownames(A)))  rownames(A) <- rownames(Y)  else {
nnames <- length(intersect(rownames(Y), rownames(A)))
if (nnames > n)
stop("The row names of A are not the same as the row names of Y\n",
call. = FALSE)
if (isSymmetric(A))
A <- A[id, id]
else A <- A[id, ]
}
X <- matrix(1, n)
rownames(X) <- rownames(Y)
if (!is.null(Cov))
if (!is.null(Cov)) Pcov <- Cov.proj(Cov, rownames(Y))
cen <- if (is.null(Cov))
cen <- if (is.null(Cov)) colMeans(Y)
cen <- if (is.null(Cov)) colMeans(Y) else lm.fit(Pcov %*% X, Pcov %*% Y)$coefficients
Z <- scale(Y, center = cen, scale = scale.)
cen <- attr(Z, "scaled:center")
sc <- attr(Z, "scaled:scale")
if (any(sc == 0))  stop("cannot rescale a constant/zero column to unit variance")
k <- if (!is.null(rank.)) {
stopifnot(length(rank.) == 1, is.finite(rank.), as.integer(rank.) >
0)
min(as.integer(rank.), n, p)
}
k <- if (!is.null(rank.)) {
stopifnot(length(rank.) == 1, is.finite(rank.), as.integer(rank.) >
0)
min(as.integer(rank.), n, p)
}else min(n, p)
tf <- if (!is.null(Cov) && transform.)   TRUE   else FALSE
if (tf)   Z <- Pcov %*% Z
Saz <- if (tf || is.null(Cov))   crossprod(A, Z) else crossprod(A, Pcov %*% Z)
s <- svd(Saz, nu = 0, nv = k)
if (alignment != "principal") {
Sa <- crossprod(A)
Sz <- crossprod(Z)
RV <- svd(crossprod(A, Z))$d^2/sqrt(sum(Sa^2) * sum(Sz^2))
}
if (alignment != "principal") {
Sa <- crossprod(A)
Sz <- crossprod(Z)
RV <- svd(crossprod(A, Z))$d^2/sqrt(sum(Sa^2) * sum(Sz^2))
}else RV <- NULL
j <- seq_len(k)
s$v <- s$v[, j]
x <- Z %*% s$v
sy <- if (tf || is.null(Cov)) sum(svd(Z)$d^2)
sy <- if (tf || is.null(Cov)) sum(svd(Z)$d^2)else sum(svd(Pcov %*% Z)$d^2)
s$d <- s$d^2/sum(s$d^2) * sy/max(1, n - 1)
s$sdev <- sqrt(s$d)
if (!is.null(tol)) {
rank <- sum(s$sdev > (s$sdev[1L] * tol))
if (rank < k) {
j <- seq_len(k <- rank)
s$v <- s$v[, j, drop = FALSE]
s$d <- s$d[j]
s$sdev <- s$sdev[j]
x <- x[j]
}
}
s$v <- as.matrix(s$v)
dimnames(s$v) <- list(colnames(Z), paste0("Comp", j))
r <- list(d = s$d, sdev = s$sdev, rot = s$v, center = cen,
scale = if (is.null(sc)) FALSE else sc, GLS = if (is.null(Cov)) FALSE else TRUE,
transform = tf, alignment = alignment, x = x, RV = RV)
colnames(r$x) <- colnames(s$v)
rm(list = ls())
Y <- ord.args$Y
transform. <- ord.args$transform.
tol <- ord.args$tol
Cov <- NULL
scale. <- F
rank. <- NULL
newdata <- NULL
A <- NULL
Y <- try(as.matrix(Y), silent = TRUE)
if (inherits(Y, "try-error")) stop("Y must be a matrix or data frame.\n", call. = FALSE)
alignment <- if (!is.null(A)) try(deparse(substitute(A)), silent = TRUE) else "principal"
if (length(alignment) != 1) alignment <- "A"
dims <- dim(Y)
n <- dims[1]
p <- dims[2]
I <- diag(n)
id <- if (!is.null(rownames(Y)))  rownames(Y) else 1:n
if (is.null(A))  A <- I
if (!is.matrix(A))   stop("A must be a matrix with the same number of rows as Y\n",
call. = FALSE)
if (NROW(A) != n) stop("A must be a matrix with the same number of rows as data\n",
call. = FALSE)
if (is.null(rownames(A)))  rownames(A) <- rownames(Y)  else {
nnames <- length(intersect(rownames(Y), rownames(A)))
if (nnames > n)
stop("The row names of A are not the same as the row names of Y\n",
call. = FALSE)
if (isSymmetric(A))
A <- A[id, id]
else A <- A[id, ]
}
X <- matrix(1, n)
rownames(X) <- rownames(Y)
if (!is.null(Cov)) Pcov <- Cov.proj(Cov, rownames(Y))
cen <- if (is.null(Cov)) colMeans(Y) else lm.fit(Pcov %*% X, Pcov %*% Y)$coefficients
Z <- scale(Y, center = cen, scale = scale.)
cen <- attr(Z, "scaled:center")
sc <- attr(Z, "scaled:scale")
if (any(sc == 0))  stop("cannot rescale a constant/zero column to unit variance")
k <- if (!is.null(rank.)) {
stopifnot(length(rank.) == 1, is.finite(rank.), as.integer(rank.) >
0)
min(as.integer(rank.), n, p)
}else min(n, p)
tf <- if (!is.null(Cov) && transform.)   TRUE   else FALSE
if (tf)   Z <- Pcov %*% Z
Saz <- if (tf || is.null(Cov))   crossprod(A, Z) else crossprod(A, Pcov %*% Z)
s <- svd(Saz, nu = 0, nv = k)
if (alignment != "principal") {
Sa <- crossprod(A)
Sz <- crossprod(Z)
RV <- svd(crossprod(A, Z))$d^2/sqrt(sum(Sa^2) * sum(Sz^2))
}else RV <- NULL
j <- seq_len(k)
s$v <- s$v[, j]
x <- Z %*% s$v
sy <- if (tf || is.null(Cov)) sum(svd(Z)$d^2)else sum(svd(Pcov %*% Z)$d^2)
s$d <- s$d^2/sum(s$d^2) * sy/max(1, n - 1)
s$sdev <- sqrt(s$d)
if (!is.null(tol)) {
rank <- sum(s$sdev > (s$sdev[1L] * tol))
if (rank < k) {
j <- seq_len(k <- rank)
s$v <- s$v[, j, drop = FALSE]
s$d <- s$d[j]
s$sdev <- s$sdev[j]
x <- x[j]
}
}
s$v <- as.matrix(s$v)
dimnames(s$v) <- list(colnames(Z), paste0("Comp", j))
r <- list(d = s$d, sdev = s$sdev, rot = s$v, center = cen,
scale = if (is.null(sc)) FALSE else sc, GLS = if (is.null(Cov)) FALSE else TRUE,
transform = tf, alignment = alignment, x = x, RV = RV)
rm(list = ls())
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
geomorph:::gm.prcomp(Y.gpa$coords)
A <- Y.gpa$coords
phy <- NULL
align.to.phy <- FALSE
GLS <- FALSE
transform <- FALSE
if (is.array(A)) {
dims <- dim(A)
if (length(dims) == 3) {
if (any(is.na(A)))
stop("Data matrix contains missing values. Estimate these first (see 'estimate.missing').\n",
call. = FALSE)
p <- dims[1]
k <- dims[2]
n <- dims[3]
}
else if (length(dims) == 2) {
n <- dims[1]
k <- NULL
p <- dims[2]
}
}else {
A <- try(as.matrix(A), silent = TRUE)
if (inherits(A, "try-error"))
stop("Data not of a form coercible to matrix or array.\n",
call. = FALSE)
dims <- dim(A)
n <- dims[1]
k <- NULL
p <- dims[2]
}
ord.args <- list(...)
ord.args <- list() ##########
if (!is.null(k)) {
Y <- two.d.array(A)
ord.args$Y <- Y
} else ord.args$Y <- Y <- A
if (is.null(ord.args$tol)) ord.args$tol <- sqrt(.Machine$double.eps)
if (!is.null(phy)) {
if (!inherits(phy, "phylo"))
stop("Tree must be of class 'phylo.'\n", call. = FALSE)
N <- length(phy$tip.label)
Nnode <- phy$Nnode
if (N != n)
stop("Number of taxa in data matrix and tree are not equal.\n",
call. = FALSE)
if (is.null(rownames(Y))) {
warning("Shape dataset does not include species names. Assuming the order of data matches phy$tip.label")
rownames(Y) <- phy$tip.label
}
ancY <- anc.BM(phy, Y)
if (is.null(rownames(Y))) {
rownames(Y) <- phy$tip.label
cat("Warning: Data are not labeled so it is assumed they are in the same order as tree names.\n")
}
phy.mat <- phylo.mat(Y, phy)
C <- phy.mat$C
if (align.to.phy)
ord.args$A <- C
if (GLS)
ord.args$Cov <- C
}
ord.args$transform. = transform
out <- do.call(ordinate, ord.args)
Y <- ord.args$Y
transform. <- ord.args$transform.
tol <- ord.args$tol
Cov <- NULL
scale. <- F
rank. <- NULL
newdata <- NULL
A <- NULL
Y <- try(as.matrix(Y), silent = TRUE)
if (inherits(Y, "try-error")) stop("Y must be a matrix or data frame.\n", call. = FALSE)
alignment <- if (!is.null(A)) try(deparse(substitute(A)), silent = TRUE) else "principal"
if (length(alignment) != 1) alignment <- "A"
dims <- dim(Y)
n <- dims[1]
p <- dims[2]
I <- diag(n)
id <- if (!is.null(rownames(Y)))  rownames(Y) else 1:n
if (is.null(A))  A <- I
if (!is.matrix(A))   stop("A must be a matrix with the same number of rows as Y\n",
call. = FALSE)
if (NROW(A) != n) stop("A must be a matrix with the same number of rows as data\n",
call. = FALSE)
if (is.null(rownames(A)))  rownames(A) <- rownames(Y)  else {
nnames <- length(intersect(rownames(Y), rownames(A)))
if (nnames > n)
stop("The row names of A are not the same as the row names of Y\n",
call. = FALSE)
if (isSymmetric(A))
A <- A[id, id]
else A <- A[id, ]
}
X <- matrix(1, n)
rownames(X) <- rownames(Y)
if (!is.null(Cov)) Pcov <- Cov.proj(Cov, rownames(Y))
cen <- if (is.null(Cov)) colMeans(Y) else lm.fit(Pcov %*% X, Pcov %*% Y)$coefficients
Z <- scale(Y, center = cen, scale = scale.)
cen <- attr(Z, "scaled:center")
sc <- attr(Z, "scaled:scale")
if (any(sc == 0))  stop("cannot rescale a constant/zero column to unit variance")
k <- if (!is.null(rank.)) {
stopifnot(length(rank.) == 1, is.finite(rank.), as.integer(rank.) >
0)
min(as.integer(rank.), n, p)
}else min(n, p)
tf <- if (!is.null(Cov) && transform.)   TRUE   else FALSE
if (tf)   Z <- Pcov %*% Z
Saz <- if (tf || is.null(Cov))   crossprod(A, Z) else crossprod(A, Pcov %*% Z)
s <- svd(Saz, nu = 0, nv = k)
if (alignment != "principal") {
Sa <- crossprod(A)
Sz <- crossprod(Z)
RV <- svd(crossprod(A, Z))$d^2/sqrt(sum(Sa^2) * sum(Sz^2))
}else RV <- NULL
j <- seq_len(k)
s$v <- s$v[, j]
x <- Z %*% s$v
sy <- if (tf || is.null(Cov)) sum(svd(Z)$d^2)else sum(svd(Pcov %*% Z)$d^2)
s$d <- s$d^2/sum(s$d^2) * sy/max(1, n - 1)
s$sdev <- sqrt(s$d)
if (!is.null(tol)) {
rank <- sum(s$sdev > (s$sdev[1L] * tol))
if (rank < k) {
j <- seq_len(k <- rank)
s$v <- s$v[, j, drop = FALSE]
s$d <- s$d[j]
s$sdev <- s$sdev[j]
x <- x[j]
}
}
s$v <- as.matrix(s$v)
dimnames(s$v) <- list(colnames(Z), paste0("Comp", j))
r <- list(d = s$d, sdev = s$sdev, rot = s$v, center = cen,
scale = if (is.null(sc)) FALSE else sc, GLS = if (is.null(Cov)) FALSE else TRUE,
transform = tf, alignment = alignment, x = x, RV = RV)
colnames(r$x) <- colnames(s$v)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
library(geomorph)data(plethspecies)
library(geomorph)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
gm.prcomp(Y.gpa$coords)
ls()
install.packages("geomorph")
install.packages("geomorph")
library(geomorph)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
gm.prcomp(Y.gpa$coords)
devtools::install_github("geomorphR/geomorph", ref = "Develop")
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
Y.gpa <- gpagen(plethspecies$land)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
gm.prcomp(Y.gpa$coords)
library(geomorph)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
gm.prcomp(Y.gpa$coords)
devtools::install_github("geomorphR/geomorph", ref = "Stable")
library(geomorph)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
gm.prcomp(Y.gpa$coords)
library(geomorph)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
gm.prcomp(Y.gpa$coords)
install.packages("geomorph")
install.packages("geomorph")
library(geomorph)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
gm.prcomp(Y.gpa$coords)
shiny::runApp('published')
runApp('in_development')
devtools::install_github("geomorphR/geomorph", ref = "Develop")
library(geomorph)
data(plethspecies)
library(geomorph)
devtools::install_github("geomorphR/geomorph", ref = "Develop")
devtools::install_github("geomorphR/geomorph", ref = "Develop", force = T)
library(geomorph)
remove.packages("geomorph")
devtools::install_github("geomorphR/geomorph", ref = "Develop", force = T)
library(geomorph)
devtools::install_github("geomorphR/geomorph", ref = "Stable", force = T)
library(geomorph)
install.packages("geomorph")
library(geomorph)
library(geomorph)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
d <- gm.prcomp(Y.gpa$coords)
detach("package:geomorph", unload = TRUE)
devtools::install_github("geomorphR/geomorph", ref = "Develop", force = T)
#install.packages("geomorph")
library(geomorph)
#install.packages("geomorph")
library(geomorph)
install.packages("geomorph")
library(geomorph)
library(geomorph)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
d <- gm.prcomp(Y.gpa$coords)
detach("package:geomorph", unload = TRUE)
remove.packages("geomorph")
devtools::install_github("geomorphR/geomorph", ref = "Develop")
#install.packages("geomorph")
library(geomorph)
#install.packages("geomorph")
library(geomorph)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
d <- gm.prcomp(Y.gpa$coords)
#install.packages("geomorph")
library(geomorph)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
d <- gm.prcomp(Y.gpa$coords)
#install.packages("geomorph")
library(geomorph)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
d <- gm.prcomp(Y.gpa$coords)
#install.packages("geomorph")
library(geomorph)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
d <- gm.prcomp(Y.gpa$coords)
detach("package:geomorph", unload = TRUE)
remove.packages("geomorph")
install.packages("geomorph")
library(geomorph)
data(plethspecies)
#install.packages("geomorph")
library(geomorph)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
d <- gm.prcomp(Y.gpa$coords)
detach("package:geomorph", unload = TRUE)
remove.packages("geomorph")
devtools::install_github("geomorphR/geomorph", ref = "Develop")
devtools::install_github("RRPP/geomorph", ref = "Develop")
devtools::install_github("mlcollyer/RRPP", ref = "develop")
#install.packages("geomorph")
library(geomorph)
#install.packages("geomorph")
library(geomorph)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
d <- gm.prcomp(Y.gpa$coords)
shiny::runApp('in_development')
runApp('in_development')
runApp('in_development')
View(updateOrderInput)
runApp('in_development')
View(updateOrderInput)
runApp('in_development')
View(updateOrderInput)
runApp('in_development')
View(updateOrderInput)
View(updateOrderInput)
View(updateOrderInput)
View(tryObserveEvent)
View(tryObserveEvent)
runApp('in_development')
runApp('in_development')
shiny::runApp('in_development')
runApp('in_development')
runApp('in_development')
runApp('in_development')
runApp('in_development')
runApp('in_development')
runApp('in_development')
runApp('in_development')
shiny::runApp('in_development')
runApp('in_development')
runApp('in_development')
runApp('in_development')
shiny::runApp('in_development')
shiny::runApp('in_development')
runApp('in_development')
runApp('in_development')
runApp('in_development')
runApp('in_development')
runApp('published')
devtools::install_github("mlcollyer/RRPP", ref = "develop")
shiny::runApp('in_development')
runApp('in_development')
runApp('in_development')
runApp('in_development')
runApp('in_development')
runApp('in_development')
warnings()
runApp('in_development')
runApp('in_development')
rsconnect::terminateApp("shiny_test")
rsconnect::terminateApp("Shiny-Test")
rsconnect::terminateApp("Shiny_test-tutorial")
rsconnect::terminateApp("Shiny_test-geomorph")
?require
remove.packages("ape")
remove.packages("prettycode")
install.packages("shiny", "shinyjs", "shinyWidgets", "shinydashboard", "shinythemes", "shinyalert",
"shinyMatrix", "shinyjqui", "shinymeta", "prettycode",
"ape", "stringr", "stringi", "shinyforms",
"RColorBrewer", "reactlog", "StereoMorph", "shinybusy")
install.packages("shiny", "shinyjs", "shinyWidgets", "shinydashboard", "shinythemes", "shinyalert", "shinyMatrix", "shinyjqui", "shinymeta", "prettycode", "ape", "stringr", "stringi", "shinyforms", "RColorBrewer", "reactlog", "StereoMorph", "shinybusy")
?install.packages
install.packages(c("shiny", "shinyjs", "shinyWidgets", "shinydashboard", "shinythemes", "shinyalert",
"shinyMatrix", "shinyjqui", "shinymeta", "prettycode",
"ape", "stringr", "stringi", "shinyforms",
"RColorBrewer", "reactlog", "StereoMorph", "shinybusy"))
library(shiny); library(shinyjs); library(shinyWidgets); library(shinydashboard); library(shinythemes)
library(shinyalert); library(shinyMatrix); library(shinyjqui); library(shinymeta); library(prettycode)
library(geomorph); library(ape); library(stringr); library(stringi); library(shinyforms)
library(RColorBrewer); library(reactlog); library(StereoMorph); library(shinybusy)
