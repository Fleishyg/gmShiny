dimnames(s$v) <- list(colnames(Z), paste0("Comp", j))
r <- list(d = s$d, sdev = s$sdev, rot = s$v, center = cen,
scale = if (is.null(sc)) FALSE else sc, GLS = if (is.null(Cov)) FALSE else TRUE,
transform = tf, alignment = alignment, x = x, RV = RV)
colnames(r$x) <- colnames(s$v)
rm(list = ls())
Y <- ord.args$Y
transform. <- ord.args$transform.
tol <- ord.args$tol
Cov <- NULL
scale. <- F
rank. <- NULL
newdata <- NULL
A <- NULL
Y <- try(as.matrix(Y), silent = TRUE)
if (inherits(Y, "try-error")) stop("Y must be a matrix or data frame.\n", call. = FALSE)
alignment <- if (!is.null(A)) try(deparse(substitute(A)), silent = TRUE) else "principal"
if (length(alignment) != 1) alignment <- "A"
dims <- dim(Y)
n <- dims[1]
p <- dims[2]
I <- diag(n)
id <- if (!is.null(rownames(Y)))  rownames(Y) else 1:n
if (is.null(A))  A <- I
if (!is.matrix(A))   stop("A must be a matrix with the same number of rows as Y\n",
call. = FALSE)
if (NROW(A) != n) stop("A must be a matrix with the same number of rows as data\n",
call. = FALSE)
if (is.null(rownames(A)))  rownames(A) <- rownames(Y)  else {
nnames <- length(intersect(rownames(Y), rownames(A)))
if (nnames > n)
stop("The row names of A are not the same as the row names of Y\n",
call. = FALSE)
if (isSymmetric(A))
A <- A[id, id]
else A <- A[id, ]
}
X <- matrix(1, n)
rownames(X) <- rownames(Y)
if (!is.null(Cov)) Pcov <- Cov.proj(Cov, rownames(Y))
cen <- if (is.null(Cov)) colMeans(Y) else lm.fit(Pcov %*% X, Pcov %*% Y)$coefficients
Z <- scale(Y, center = cen, scale = scale.)
cen <- attr(Z, "scaled:center")
sc <- attr(Z, "scaled:scale")
if (any(sc == 0))  stop("cannot rescale a constant/zero column to unit variance")
k <- if (!is.null(rank.)) {
stopifnot(length(rank.) == 1, is.finite(rank.), as.integer(rank.) >
0)
min(as.integer(rank.), n, p)
}else min(n, p)
tf <- if (!is.null(Cov) && transform.)   TRUE   else FALSE
if (tf)   Z <- Pcov %*% Z
Saz <- if (tf || is.null(Cov))   crossprod(A, Z) else crossprod(A, Pcov %*% Z)
s <- svd(Saz, nu = 0, nv = k)
if (alignment != "principal") {
Sa <- crossprod(A)
Sz <- crossprod(Z)
RV <- svd(crossprod(A, Z))$d^2/sqrt(sum(Sa^2) * sum(Sz^2))
}else RV <- NULL
j <- seq_len(k)
s$v <- s$v[, j]
x <- Z %*% s$v
sy <- if (tf || is.null(Cov)) sum(svd(Z)$d^2)else sum(svd(Pcov %*% Z)$d^2)
s$d <- s$d^2/sum(s$d^2) * sy/max(1, n - 1)
s$sdev <- sqrt(s$d)
if (!is.null(tol)) {
rank <- sum(s$sdev > (s$sdev[1L] * tol))
if (rank < k) {
j <- seq_len(k <- rank)
s$v <- s$v[, j, drop = FALSE]
s$d <- s$d[j]
s$sdev <- s$sdev[j]
x <- x[j]
}
}
s$v <- as.matrix(s$v)
dimnames(s$v) <- list(colnames(Z), paste0("Comp", j))
r <- list(d = s$d, sdev = s$sdev, rot = s$v, center = cen,
scale = if (is.null(sc)) FALSE else sc, GLS = if (is.null(Cov)) FALSE else TRUE,
transform = tf, alignment = alignment, x = x, RV = RV)
rm(list = ls())
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
geomorph:::gm.prcomp(Y.gpa$coords)
A <- Y.gpa$coords
phy <- NULL
align.to.phy <- FALSE
GLS <- FALSE
transform <- FALSE
if (is.array(A)) {
dims <- dim(A)
if (length(dims) == 3) {
if (any(is.na(A)))
stop("Data matrix contains missing values. Estimate these first (see 'estimate.missing').\n",
call. = FALSE)
p <- dims[1]
k <- dims[2]
n <- dims[3]
}
else if (length(dims) == 2) {
n <- dims[1]
k <- NULL
p <- dims[2]
}
}else {
A <- try(as.matrix(A), silent = TRUE)
if (inherits(A, "try-error"))
stop("Data not of a form coercible to matrix or array.\n",
call. = FALSE)
dims <- dim(A)
n <- dims[1]
k <- NULL
p <- dims[2]
}
ord.args <- list(...)
ord.args <- list() ##########
if (!is.null(k)) {
Y <- two.d.array(A)
ord.args$Y <- Y
} else ord.args$Y <- Y <- A
if (is.null(ord.args$tol)) ord.args$tol <- sqrt(.Machine$double.eps)
if (!is.null(phy)) {
if (!inherits(phy, "phylo"))
stop("Tree must be of class 'phylo.'\n", call. = FALSE)
N <- length(phy$tip.label)
Nnode <- phy$Nnode
if (N != n)
stop("Number of taxa in data matrix and tree are not equal.\n",
call. = FALSE)
if (is.null(rownames(Y))) {
warning("Shape dataset does not include species names. Assuming the order of data matches phy$tip.label")
rownames(Y) <- phy$tip.label
}
ancY <- anc.BM(phy, Y)
if (is.null(rownames(Y))) {
rownames(Y) <- phy$tip.label
cat("Warning: Data are not labeled so it is assumed they are in the same order as tree names.\n")
}
phy.mat <- phylo.mat(Y, phy)
C <- phy.mat$C
if (align.to.phy)
ord.args$A <- C
if (GLS)
ord.args$Cov <- C
}
ord.args$transform. = transform
out <- do.call(ordinate, ord.args)
Y <- ord.args$Y
transform. <- ord.args$transform.
tol <- ord.args$tol
Cov <- NULL
scale. <- F
rank. <- NULL
newdata <- NULL
A <- NULL
Y <- try(as.matrix(Y), silent = TRUE)
if (inherits(Y, "try-error")) stop("Y must be a matrix or data frame.\n", call. = FALSE)
alignment <- if (!is.null(A)) try(deparse(substitute(A)), silent = TRUE) else "principal"
if (length(alignment) != 1) alignment <- "A"
dims <- dim(Y)
n <- dims[1]
p <- dims[2]
I <- diag(n)
id <- if (!is.null(rownames(Y)))  rownames(Y) else 1:n
if (is.null(A))  A <- I
if (!is.matrix(A))   stop("A must be a matrix with the same number of rows as Y\n",
call. = FALSE)
if (NROW(A) != n) stop("A must be a matrix with the same number of rows as data\n",
call. = FALSE)
if (is.null(rownames(A)))  rownames(A) <- rownames(Y)  else {
nnames <- length(intersect(rownames(Y), rownames(A)))
if (nnames > n)
stop("The row names of A are not the same as the row names of Y\n",
call. = FALSE)
if (isSymmetric(A))
A <- A[id, id]
else A <- A[id, ]
}
X <- matrix(1, n)
rownames(X) <- rownames(Y)
if (!is.null(Cov)) Pcov <- Cov.proj(Cov, rownames(Y))
cen <- if (is.null(Cov)) colMeans(Y) else lm.fit(Pcov %*% X, Pcov %*% Y)$coefficients
Z <- scale(Y, center = cen, scale = scale.)
cen <- attr(Z, "scaled:center")
sc <- attr(Z, "scaled:scale")
if (any(sc == 0))  stop("cannot rescale a constant/zero column to unit variance")
k <- if (!is.null(rank.)) {
stopifnot(length(rank.) == 1, is.finite(rank.), as.integer(rank.) >
0)
min(as.integer(rank.), n, p)
}else min(n, p)
tf <- if (!is.null(Cov) && transform.)   TRUE   else FALSE
if (tf)   Z <- Pcov %*% Z
Saz <- if (tf || is.null(Cov))   crossprod(A, Z) else crossprod(A, Pcov %*% Z)
s <- svd(Saz, nu = 0, nv = k)
if (alignment != "principal") {
Sa <- crossprod(A)
Sz <- crossprod(Z)
RV <- svd(crossprod(A, Z))$d^2/sqrt(sum(Sa^2) * sum(Sz^2))
}else RV <- NULL
j <- seq_len(k)
s$v <- s$v[, j]
x <- Z %*% s$v
sy <- if (tf || is.null(Cov)) sum(svd(Z)$d^2)else sum(svd(Pcov %*% Z)$d^2)
s$d <- s$d^2/sum(s$d^2) * sy/max(1, n - 1)
s$sdev <- sqrt(s$d)
if (!is.null(tol)) {
rank <- sum(s$sdev > (s$sdev[1L] * tol))
if (rank < k) {
j <- seq_len(k <- rank)
s$v <- s$v[, j, drop = FALSE]
s$d <- s$d[j]
s$sdev <- s$sdev[j]
x <- x[j]
}
}
s$v <- as.matrix(s$v)
dimnames(s$v) <- list(colnames(Z), paste0("Comp", j))
r <- list(d = s$d, sdev = s$sdev, rot = s$v, center = cen,
scale = if (is.null(sc)) FALSE else sc, GLS = if (is.null(Cov)) FALSE else TRUE,
transform = tf, alignment = alignment, x = x, RV = RV)
colnames(r$x) <- colnames(s$v)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
library(geomorph)data(plethspecies)
library(geomorph)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
gm.prcomp(Y.gpa$coords)
ls()
install.packages("geomorph")
install.packages("geomorph")
library(geomorph)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
gm.prcomp(Y.gpa$coords)
devtools::install_github("geomorphR/geomorph", ref = "Develop")
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
Y.gpa <- gpagen(plethspecies$land)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
gm.prcomp(Y.gpa$coords)
library(geomorph)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
gm.prcomp(Y.gpa$coords)
devtools::install_github("geomorphR/geomorph", ref = "Stable")
library(geomorph)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
gm.prcomp(Y.gpa$coords)
library(geomorph)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
gm.prcomp(Y.gpa$coords)
install.packages("geomorph")
install.packages("geomorph")
library(geomorph)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
gm.prcomp(Y.gpa$coords)
shiny::runApp('published')
runApp('in_development')
devtools::install_github("geomorphR/geomorph", ref = "Develop")
library(geomorph)
data(plethspecies)
library(geomorph)
devtools::install_github("geomorphR/geomorph", ref = "Develop")
devtools::install_github("geomorphR/geomorph", ref = "Develop", force = T)
library(geomorph)
remove.packages("geomorph")
devtools::install_github("geomorphR/geomorph", ref = "Develop", force = T)
library(geomorph)
devtools::install_github("geomorphR/geomorph", ref = "Stable", force = T)
library(geomorph)
install.packages("geomorph")
library(geomorph)
library(geomorph)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
d <- gm.prcomp(Y.gpa$coords)
detach("package:geomorph", unload = TRUE)
devtools::install_github("geomorphR/geomorph", ref = "Develop", force = T)
#install.packages("geomorph")
library(geomorph)
#install.packages("geomorph")
library(geomorph)
install.packages("geomorph")
library(geomorph)
library(geomorph)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
d <- gm.prcomp(Y.gpa$coords)
detach("package:geomorph", unload = TRUE)
remove.packages("geomorph")
devtools::install_github("geomorphR/geomorph", ref = "Develop")
#install.packages("geomorph")
library(geomorph)
#install.packages("geomorph")
library(geomorph)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
d <- gm.prcomp(Y.gpa$coords)
#install.packages("geomorph")
library(geomorph)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
d <- gm.prcomp(Y.gpa$coords)
#install.packages("geomorph")
library(geomorph)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
d <- gm.prcomp(Y.gpa$coords)
#install.packages("geomorph")
library(geomorph)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
d <- gm.prcomp(Y.gpa$coords)
detach("package:geomorph", unload = TRUE)
remove.packages("geomorph")
install.packages("geomorph")
library(geomorph)
data(plethspecies)
#install.packages("geomorph")
library(geomorph)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
d <- gm.prcomp(Y.gpa$coords)
detach("package:geomorph", unload = TRUE)
remove.packages("geomorph")
devtools::install_github("geomorphR/geomorph", ref = "Develop")
devtools::install_github("RRPP/geomorph", ref = "Develop")
devtools::install_github("mlcollyer/RRPP", ref = "develop")
#install.packages("geomorph")
library(geomorph)
#install.packages("geomorph")
library(geomorph)
data(plethspecies)
Y.gpa <- gpagen(plethspecies$land)
d <- gm.prcomp(Y.gpa$coords)
shiny::runApp('in_development')
runApp('in_development')
runApp('in_development')
View(updateOrderInput)
runApp('in_development')
View(updateOrderInput)
runApp('in_development')
View(updateOrderInput)
runApp('in_development')
View(updateOrderInput)
View(updateOrderInput)
View(updateOrderInput)
View(tryObserveEvent)
View(tryObserveEvent)
runApp('in_development')
runApp('in_development')
shiny::runApp('in_development')
runApp('in_development')
runApp('in_development')
runApp('in_development')
runApp('in_development')
runApp('in_development')
runApp('in_development')
runApp('in_development')
shiny::runApp('in_development')
runApp('in_development')
runApp('in_development')
runApp('in_development')
shiny::runApp('in_development')
shiny::runApp('in_development')
runApp('in_development')
runApp('in_development')
runApp('in_development')
runApp('in_development')
runApp('published')
devtools::install_github("mlcollyer/RRPP", ref = "develop")
shiny::runApp('in_development')
runApp('in_development')
runApp('in_development')
runApp('in_development')
runApp('in_development')
runApp('in_development')
warnings()
runApp('in_development')
runApp('in_development')
rsconnect::terminateApp("shiny_test")
rsconnect::terminateApp("Shiny-Test")
rsconnect::terminateApp("Shiny_test-tutorial")
rsconnect::terminateApp("Shiny_test-geomorph")
?require
remove.packages("ape")
remove.packages("prettycode")
install.packages("shiny", "shinyjs", "shinyWidgets", "shinydashboard", "shinythemes", "shinyalert",
"shinyMatrix", "shinyjqui", "shinymeta", "prettycode",
"ape", "stringr", "stringi", "shinyforms",
"RColorBrewer", "reactlog", "StereoMorph", "shinybusy")
install.packages("shiny", "shinyjs", "shinyWidgets", "shinydashboard", "shinythemes", "shinyalert", "shinyMatrix", "shinyjqui", "shinymeta", "prettycode", "ape", "stringr", "stringi", "shinyforms", "RColorBrewer", "reactlog", "StereoMorph", "shinybusy")
?install.packages
install.packages(c("shiny", "shinyjs", "shinyWidgets", "shinydashboard", "shinythemes", "shinyalert",
"shinyMatrix", "shinyjqui", "shinymeta", "prettycode",
"ape", "stringr", "stringi", "shinyforms",
"RColorBrewer", "reactlog", "StereoMorph", "shinybusy"))
library(shiny); library(shinyjs); library(shinyWidgets); library(shinydashboard); library(shinythemes)
library(shinyalert); library(shinyMatrix); library(shinyjqui); library(shinymeta); library(prettycode)
library(geomorph); library(ape); library(stringr); library(stringi); library(shinyforms)
library(RColorBrewer); library(reactlog); library(StereoMorph); library(shinybusy)
remotes::install_github("geomorphR/geomorph", ref = "Stable", build_vignettes = F) # only necessary for first time users or after an update to gmShiny or geomorph's Stable branch
install.packages(c("shiny", "shinyjs", "shinyWidgets", "shinydashboard", "shinythemes", "shinyalert", "shinyMatrix", "shinyjqui", "shinymeta", "prettycode", "ape", "stringr", "stringi", "shinyforms", "RColorBrewer", "reactlog", "StereoMorph", "shinybusy")) # only necessary for first time users or after an update to gmShiny
shiny::runUrl("https://github.com/geomorphR/gmShiny/archive/master.tar.gz")
load("~/Downloads/data_current_state-2021-06-15_15.56.14.RData")
vals <- vals2
library(geomorph)
pr <- pca_rx
class(pr) <- "ordinate"
if (!is.null(vals$tip_pch)) {
input_pch <- as.numeric(vals$tip_pch)
} else {
input_pch <- 19
}
pr.plot <- RRPP:::plot.ordinate(pr, axis1 = as.numeric("1"), axis2 = as.numeric("2"), pch = input_pch, cex = as.numeric(1L), col = vals$tip_col, asp = 1)
abline(h = 0, lty = 2)
abline(v = 0, lty = 2)
if (FALSE) {
text(pr.plot$points, rownames(pr.plot$points), adj = c(-(1L)/15, -(1L)/15), cex = as.numeric(1L), col = vals$tip_col)
}
if (FALSE) {
z <- vals$morphospace$phylo$phy.pcdata
if (length(vals$input.flip_axis) > 0) {
if (1 %in% vals$input.flip_axis) {
z[, 1] <- vals$morphospace$phylo$phy.pcdata[, 1] * -1
}
if (2 %in% vals$input.flip_axis) {
z[, 2] <- vals$morphospace$phylo$phy.pcdata[, 2] * -1
}
}
edges <- as.matrix(vals$phy_rx$edge)
for (i in 1:NROW(edges)) {
pts <- z[edges[i, ], ]
points(pts, type = "l", col = "black", lwd = as.numeric(1L), lty = 1)
}
ancs <- z[(length(vals$phy_rx$tip.label) + 1):nrow(z), ]
points(ancs, pch = as.numeric("19"), cex = as.numeric(1L), col = "#737373")
if (FALSE) {
text(ancs, rownames(ancs), adj = c(-(1L)/15, -(1L)/15), cex = as.numeric(1L), col = "#737373")
}
}
if (!is.null(vals$morpho_clicked)) {
if (TRUE) {
points(x = vals$specimen_row_ref[, as.numeric("1")], y = vals$specimen_row_ref[, as.numeric("2")], col = "red", cex = as.numeric(1L) + 1.2, pch = 1)
}
if ("selected_obs_byname" == "selected_obs") {
points(x = vals$specimen_row_targ[, as.numeric("1")], y = vals$specimen_row_targ[, as.numeric("2")], col = "red", cex = as.numeric(1L) + 1, pch = 1)
}
}
if (is.null(vals$morpho_dbclicked) == "FALSE") {
points(x = vals$projection_row[1], y = vals$projection_row[2], col = "red", cex = as.numeric(1L) + 1, pch = 4)
}
if (TRUE == TRUE) {
if (!is.null("selected_obs_byname")) {
if ("selected_obs" == "mean") {
start.xy <- c(0, 0)
}
if ("selected_obs" == "selected_proj") {
start.xy <- vals$projection_row[1:2]
}
if ("selected_obs" == "selected_obs" | "selected_obs" == "selected_obs_byname") {
start.xy <- c(as.numeric(vals$specimen_row_ref[, as.numeric("1")]), as.numeric(vals$specimen_row_ref[, as.numeric("2")]))
}
if ("selected_obs_byname" == "mean") {
end.xy <- c(0, 0)
}
if ("selected_obs_byname" == "selected_proj") {
end.xy <- vals$projection_row[1:2]
}
if ("selected_obs_byname" == "selected_obs" | "selected_obs_byname" == "selected_obs_byname") {
end.xy <- c(as.numeric(vals$specimen_row_targ[, as.numeric("1")]), as.numeric(vals$specimen_row_targ[, as.numeric("2")]))
}
arrows(x0 = start.xy[1], y0 = start.xy[2], x1 = end.xy[1], y1 = end.xy[2], col = "red", lty = 1, lwd = 2)
}
}
if (FALSE | FALSE | FALSE) {
selected_trait <- (2:4)[c(FALSE, FALSE, FALSE)]
colored_tips <- (2:4)[c("all_1_col" == "by_trait_1", "all_1_col" == "by_trait_2", "all_1_col" == "by_trait_3")]
col_list_modified <- list(vals$color_options_list$hull1, vals$color_options_list$hull2, vals$color_options_list$tips)
if (length(colored_tips) == 0) {
col_list_modified <- list(vals$color_options_list$hull1, vals$color_options_list$hull2, vals$color_options_list$hull3)
}
if (length(colored_tips) > 0) {
if (colored_tips == selected_trait[1]) {
col_list_modified <- list(vals$color_options_list$tips, vals$color_options_list$hull1, vals$color_options_list$hull2)
}         else {
if (length(selected_trait) > 1) {
if (colored_tips == selected_trait[2]) {
col_list_modified <- list(vals$color_options_list$hull1, vals$color_options_list$tips, vals$color_options_list$hull2)
}
}
}
}
for (i in 1:length(selected_trait)) {
this_col <- selected_trait[i]
tip_col_fac <- as.character(vals$trait_rx[match(dimnames(gpa_coords)[[3]], vals$trait_rx[, 1]), this_col])
lev <- length(unique(tip_col_fac))
lev_options <- unique(tip_col_fac)
col_mat <- unlist(col_list_modified[[i]])
for (j in 1:length(unique(tip_col_fac))) {
reordered_edges <- pr$x[which(tip_col_fac == lev_options[j]), c(as.numeric("1"), as.numeric("2"))]
edge_points <- row.names(reordered_edges)[chull(reordered_edges)]
polygon(x = pr$x[edge_points, as.numeric("1")], y = pr$x[edge_points, as.numeric("2")], col = adjustcolor(col_mat[j], alpha.f = 0.5), border = col_mat[j])
}
}
}
